{"version":3,"sources":["../src/json-patch-queue-synchronous.js"],"names":["JSONPatchQueueSynchronous","versionPath","apply","purist","this","waiting","prototype","version","receive","obj","versionedJsonPatch","applyCallback","consecutivePatch","slice","shift","replaceVersion","newVersion","value","Error","send","sequence","newSequence","unshift","op","path","getPropertyByJsonPointer","pointer","parts","split","target","length","replace","reset","newState","patch","undefined","module","exports","default","__esModule"],"mappings":"AAOA,GAAIA,2BAA4B,SAASC,EAAaC,EAAOC,GAM5DC,KAAKC,WAKLD,KAAKH,YAAcA,EAKnBG,KAAKF,MAAQA,EAKbE,KAAKD,OAASA,EAGfH,2BAA0BM,UAAUC,QAAU,EAW9CP,0BAA0BM,UAAUE,QAAU,SAASC,EAAKC,EAAoBC,GAC/E,GAAIT,GAAQS,GAAiBP,KAAKF,MACjCU,EAAmBF,EAAmBG,MAAM,EAE5C,IAAGT,KAAKD,OACP,CAAiBS,EAAiBE,QAEnC,GAAIC,GAAiBH,EAAiBE,QACrCE,EAAaD,EAAeE,KAI9B,IAAID,GAAcZ,KAAKG,QAEnB,KAAM,IAAIW,OAAM,qCACb,IAAKF,GAAcZ,KAAKG,QAAU,EAExC,KAAOK,GACNR,KAAKG,UACLL,EAAMO,EAAKG,GACXA,EAAmBR,KAAKC,QAAQS,YAIjCV,MAAKC,QAAQW,EAAaZ,KAAKG,QAAS,GAAKK,GAQ/CZ,0BAA0BM,UAAUa,KAAO,SAASC,GACnDhB,KAAKG,SACL,IAAIc,GAAcD,EAASP,MAAM,EAajC,OAZAQ,GAAYC,SACXC,GAAI,UACJC,KAAMpB,KAAKH,YACXgB,MAAOb,KAAKG,UAEVH,KAAKD,QACPkB,EAAYC,SACXC,GAAI,OACJC,KAAMpB,KAAKH,YACXgB,MAAOb,KAAKG,QAAQ,IAGfc,GAGRrB,0BAA0ByB,yBAA2B,SAAShB,EAAKiB,GAClE,GAAIC,GAAQD,EAAQE,MAAM,IACV,MAAbD,EAAM,IACRA,EAAMb,OAGP,KADA,GAAIe,GAASpB,EACPkB,EAAMG,QAAQ,CACnB,GAAIN,GAAOG,EAAMb,QAAQiB,QAAQ,KAAM,KAAKA,QAAQ,KAAM,IACvDJ,GAAMG,SACRD,EAASA,EAAOL,IAGlB,MAAOK,GAAOL,IAQfxB,0BAA0BM,UAAU0B,MAAQ,SAASvB,EAAKwB,GACzD7B,KAAKG,QAAUP,0BAA0ByB,yBAAyBQ,EAAU7B,KAAKH,aACjFG,KAAKC,UACL,IAAI6B,KAAWX,GAAI,UAAWC,KAAM,GAAIP,MAAOgB,GAC/C7B,MAAKF,MAAMO,EAAKyB,IAGIC,eAAXC,UACTA,OAAOC,QAAUrC,0BACjBoC,OAAOC,QAAQC,QAAUtC,0BAEzBoC,OAAOC,QAAQE,YAAa","file":"json-patch-queue-synchronous.min.js","sourcesContent":["/**\r\n * JSON Patch Queue for synchronous operations, and asynchronous networking.\r\n * @param {JSON-Pointer} versionPath JSON-Pointers to version numbers\r\n * @param {function} apply    apply(JSONobj, JSONPatchSequence) function to apply JSONPatch to object.\r\n * @param {Boolean} [purist]       If set to true adds test operation before replace.\r\n * @version: 1.0.0\r\n */\r\nvar JSONPatchQueueSynchronous = function(versionPath, apply, purist){\r\n\t/**\r\n\t * Queue of consecutive JSON Patch sequences. May contain gaps.\r\n\t * Item with index 0 has 1 sequence version gap to `this.version`.\r\n\t * @type {Array}\r\n\t */\r\n\tthis.waiting = [];\r\n\t/**\r\n\t * JSON-Pointer to local version in shared JSON document\r\n\t * @type {JSONPointer}\r\n\t */\r\n\tthis.versionPath = versionPath;\r\n\t/**\r\n\t * Function to apply JSONPatchSequence to JSON object\r\n\t * @type {Function}\r\n\t */\r\n\tthis.apply = apply;\r\n\t/**\r\n\t * If set to true adds test operation before replace.\r\n\t * @type {Bool}\r\n\t */\r\n\tthis.purist = purist;\r\n};\r\n/** JSON version */\r\nJSONPatchQueueSynchronous.prototype.version = 0;\r\n//JSONPatchQueueSynchronous.prototype.purist = false;\r\n// instance property\r\n//  JSONPatchQueueSynchronous.prototype.waiting = [];\r\n/**\r\n * Process received versioned JSON Patch.\r\n * Applies or adds to queue.\r\n * @param  {Object} obj                   object to apply patches to\r\n * @param  {JSONPatch} versionedJsonPatch patch to be applied\r\n * @param  {Function} [applyCallback]     optional `function(object, consecutivePatch)` to be called when applied, if not given #apply will be called\r\n */\r\nJSONPatchQueueSynchronous.prototype.receive = function(obj, versionedJsonPatch, applyCallback){\r\n\tvar apply = applyCallback || this.apply,\r\n\t\tconsecutivePatch = versionedJsonPatch.slice(0);\r\n\t// strip Versioned JSON Patch specyfiv operation objects from given sequence\r\n\t\tif(this.purist){\r\n\t\t\tvar testRemote = consecutivePatch.shift();\r\n\t\t}\r\n\t\tvar replaceVersion = consecutivePatch.shift(),\r\n\t\t\tnewVersion = replaceVersion.value;\r\n\r\n\t// TODO: perform versionedPath validation if needed (tomalec)\r\n\r\n\tif( newVersion <= this.version){\r\n\t// someone is trying to change something that was already updated\r\n    \tthrow new Error(\"Given version was already applied.\");\r\n\t} else if ( newVersion == this.version + 1 ){\r\n\t// consecutive new version\r\n\t\twhile( consecutivePatch ){// process consecutive patch(-es)\r\n\t\t\tthis.version++;\r\n\t\t\tapply(obj, consecutivePatch);\r\n\t\t\tconsecutivePatch = this.waiting.shift();\r\n\t\t}\r\n\t} else {\r\n\t// add sequence to queue in correct position.\r\n\t\tthis.waiting[newVersion - this.version -2] = consecutivePatch;\r\n\t}\r\n};\r\n/**\r\n * Wraps JSON Patch sequence with version related operation objects\r\n * @param  {JSONPatch} sequence JSON Patch sequence to wrap\r\n * @return {VersionedJSONPatch}\r\n */\r\nJSONPatchQueueSynchronous.prototype.send = function(sequence){\r\n\tthis.version++;\r\n\tvar newSequence = sequence.slice(0);\r\n\tnewSequence.unshift({\r\n\t\top: \"replace\",\r\n\t\tpath: this.versionPath,\r\n\t\tvalue: this.version\r\n\t});\r\n\tif(this.purist){\r\n\t\tnewSequence.unshift({ // test for purist\r\n\t\t\top: \"test\",\r\n\t\t\tpath: this.versionPath,\r\n\t\t\tvalue: this.version-1\r\n\t\t});\r\n\t}\r\n\treturn newSequence;\r\n};\r\n\r\nJSONPatchQueueSynchronous.getPropertyByJsonPointer = function(obj, pointer) {\r\n\tvar parts = pointer.split('/');\r\n\tif(parts[0] === \"\") {\r\n\t\tparts.shift();\r\n\t}\r\n\tvar target = obj;\r\n\twhile(parts.length) {\r\n\t\tvar path = parts.shift().replace('~1', '/').replace('~0', '~');\r\n\t\tif(parts.length) {\r\n\t\t\ttarget = target[path];\r\n\t\t}\r\n\t}\r\n\treturn target[path];\r\n};\r\n\r\n/**\r\n * Reset queue internals and object to new, given state\r\n * @param obj object to apply new state to\r\n * @param newState versioned object representing desired state along with versions\r\n */\r\nJSONPatchQueueSynchronous.prototype.reset = function(obj, newState){\r\n\tthis.version = JSONPatchQueueSynchronous.getPropertyByJsonPointer(newState, this.versionPath);\r\n\tthis.waiting = [];\r\n\tvar patch = [{ op: \"replace\", path: \"\", value: newState }];\r\n\tthis.apply(obj, patch);\r\n};\r\n\r\nif(typeof module !== undefined) {\r\n\tmodule.exports = JSONPatchQueueSynchronous;\r\n\tmodule.exports.default = JSONPatchQueueSynchronous;\r\n\t/* Babel demands this */\r\n\tmodule.exports.__esModule = true;\r\n}"]}