{"version":3,"sources":["../src/json-patch-queue.js"],"names":["JSONPatchQueue","versionPaths","apply","purist","this","waiting","localPath","remotePath","prototype","localVersion","remoteVersion","receive","obj","versionedJsonPatch","applyCallback","consecutivePatch","slice","shift","replaceRemote","newRemoteVersion","value","Error","send","sequence","newSequence","unshift","op","path","getPropertyByJsonPointer","pointer","parts","split","target","length","replace","reset","newState","patch","undefined","module","exports","default","__esModule"],"mappings":"AAOA,GAAIA,gBAAiB,SAASC,EAAcC,EAAOC,GAMlDC,KAAKC,WAKLD,KAAKE,UAAYL,EAAa,GAK9BG,KAAKG,WAAaN,EAAa,GAK/BG,KAAKF,MAAQA,EAKbE,KAAKD,OAASA,EAIfH,gBAAeQ,UAAUC,aAAe,EAIxCT,eAAeQ,UAAUE,cAAgB,EAazCV,eAAeQ,UAAUG,QAAU,SAASC,EAAKC,EAAoBC,GACpE,GAAIZ,GAAQY,GAAiBV,KAAKF,MACjCa,EAAmBF,EAAmBG,MAAM,EAE5C,IAAGZ,KAAKD,OACP,CAAiBY,EAAiBE,QAEnC,GAAIC,GAAgBH,EAAiBE,QACpCE,EAAmBD,EAAcE,KAInC,IAAID,GAAoBf,KAAKM,cAEzB,KAAM,IAAIW,OAAM,qCACb,IAAKF,GAAoBf,KAAKM,cAAgB,EAEpD,KAAOK,GACNX,KAAKM,gBACLR,EAAMU,EAAKG,GACXA,EAAmBX,KAAKC,QAAQY,YAIjCb,MAAKC,QAAQc,EAAmBf,KAAKM,cAAe,GAAKK,GAQ3Df,eAAeQ,UAAUc,KAAO,SAASC,GACxCnB,KAAKK,cACL,IAAIe,GAAcD,EAASP,MAAM,EAkBjC,OAjBGZ,MAAKD,OACPqB,EAAYC,SACXC,GAAI,OACJC,KAAMvB,KAAKE,UACXc,MAAOhB,KAAKK,aAAe,IAE3BiB,GAAI,UACJC,KAAMvB,KAAKE,UACXc,MAAOhB,KAAKK,eAGbe,EAAYC,SACXC,GAAI,UACJC,KAAMvB,KAAKE,UACXc,MAAOhB,KAAKK,eAGPe,GAGRxB,eAAe4B,yBAA2B,SAAShB,EAAKiB,GACvD,GAAIC,GAAQD,EAAQE,MAAM,IACV,MAAbD,EAAM,IACRA,EAAMb,OAGP,KADA,GAAIe,GAASpB,EACPkB,EAAMG,QAAQ,CACnB,GAAIN,GAAOG,EAAMb,QAAQiB,QAAQ,KAAM,KAAKA,QAAQ,KAAM,IACvDJ,GAAMG,SACRD,EAASA,EAAOL,IAGlB,MAAOK,GAAOL,IAQf3B,eAAeQ,UAAU2B,MAAQ,SAASvB,EAAKwB,GAC9ChC,KAAKM,cAAgBV,eAAe4B,yBAAyBQ,EAAUhC,KAAKG,YAC5EH,KAAKC,UACL,IAAIgC,KAAWX,GAAI,UAAWC,KAAM,GAAIP,MAAOgB,GAC/ChC,MAAKF,MAAMU,EAAKyB,IAGIC,eAAXC,UACTA,OAAOC,QAAUxC,eACjBuC,OAAOC,QAAQC,QAAUzC,eAEzBuC,OAAOC,QAAQE,YAAa","file":"json-patch-queue.min.js","sourcesContent":["/**\r\n * JSON Patch Queue for asynchronous operations, and asynchronous networking.\r\n * @param {Array<JSON-Pointer>} versionPaths JSON-Pointers to version numbers [local, remote]\r\n * @param {function} apply    apply(JSONobj, JSONPatchSequence) function to apply JSONPatch to object.\r\n * @param {Boolean} [purist]       If set to true adds test operation before replace.\r\n * @version: 1.0.0\r\n */\r\nvar JSONPatchQueue = function(versionPaths, apply, purist){\r\n\t/**\r\n\t * Queue of consecutive JSON Patch sequences. May contain gaps.\r\n\t * Item with index 0 has 1 version gap to this.remoteVersion.\r\n\t * @type {Array}\r\n\t */\r\n\tthis.waiting = [];\r\n\t/**\r\n\t * JSON-Pointer to local version in shared JSON document\r\n\t * @type {JSONPointer}\r\n\t */\r\n\tthis.localPath = versionPaths[0];\r\n\t/**\r\n\t * JSON-Pointer to remote version in shared JSON document\r\n\t * @type {JSONPointer}\r\n\t */\r\n\tthis.remotePath = versionPaths[1];\r\n\t/**\r\n\t * Function to apply JSONPatchSequence to JSON object\r\n\t * @type {Function}\r\n\t */\r\n\tthis.apply = apply;\r\n\t/**\r\n\t * If set to true adds test operation before replace.\r\n\t * @type {Bool}\r\n\t */\r\n\tthis.purist = purist;\r\n\r\n};\r\n/** local version */\r\nJSONPatchQueue.prototype.localVersion = 0;\r\n/** Latest localVersion that we know that was acknowledged by remote */\r\n// JSONPatchQueue.prototype.ackVersion = 0;\r\n/** Latest acknowledged remote version */\r\nJSONPatchQueue.prototype.remoteVersion = 0;\r\n\r\n// instance property\r\n//  JSONPatchQueue.prototype.waiting = [];\r\n/** needed? OT only? */\r\n// JSONPatchQueue.prototype.pending = [];\r\n/**\r\n * Process received versioned JSON Patch\r\n * Applies or adds to queue.\r\n * @param  {Object} obj                   object to apply patches to\r\n * @param  {JSONPatch} versionedJsonPatch patch to be applied\r\n * @param  {Function} [applyCallback]     optional `function(object, consecutivePatch)` to be called when applied, if not given #apply will be called\r\n */\r\nJSONPatchQueue.prototype.receive = function(obj, versionedJsonPatch, applyCallback){\r\n\tvar apply = applyCallback || this.apply,\r\n\t\tconsecutivePatch = versionedJsonPatch.slice(0);\r\n\t// strip Versioned JSON Patch specyfiv operation objects from given sequence\r\n\t\tif(this.purist){\r\n\t\t\tvar testRemote = consecutivePatch.shift();\r\n\t\t}\r\n\t\tvar replaceRemote = consecutivePatch.shift(),\r\n\t\t\tnewRemoteVersion = replaceRemote.value;\r\n\r\n\t// TODO: perform versionedPath validation if needed (tomalec)\r\n\r\n\tif( newRemoteVersion <= this.remoteVersion){\r\n\t// someone is trying to change something that was already updated\r\n    \tthrow new Error(\"Given version was already applied.\");\r\n\t} else if ( newRemoteVersion == this.remoteVersion + 1 ){\r\n\t// consecutive new version\r\n\t\twhile( consecutivePatch ){// process consecutive patch(-es)\r\n\t\t\tthis.remoteVersion++;\r\n\t\t\tapply(obj, consecutivePatch);\r\n\t\t\tconsecutivePatch = this.waiting.shift();\r\n\t\t}\r\n\t} else {\r\n\t// add sequence to queue in correct position.\r\n\t\tthis.waiting[newRemoteVersion - this.remoteVersion -2] = consecutivePatch;\r\n\t}\r\n};\r\n/**\r\n * Wraps JSON Patch sequence with version related operation objects\r\n * @param  {JSONPatch} sequence JSON Patch sequence to wrap\r\n * @return {VersionedJSONPatch}\r\n */\r\nJSONPatchQueue.prototype.send = function(sequence){\r\n\tthis.localVersion++;\r\n\tvar newSequence = sequence.slice(0);\r\n\tif(this.purist){\r\n\t\tnewSequence.unshift({ // test for consecutiveness\r\n\t\t\top: \"test\",\r\n\t\t\tpath: this.localPath,\r\n\t\t\tvalue: this.localVersion - 1\r\n\t\t},{ // replace for queue\r\n\t\t\top: \"replace\",\r\n\t\t\tpath: this.localPath,\r\n\t\t\tvalue: this.localVersion\r\n\t\t});\r\n\t} else {\r\n\t\tnewSequence.unshift({ // replace for queue (+assumed test for consecutiveness_)\r\n\t\t\top: \"replace\",\r\n\t\t\tpath: this.localPath,\r\n\t\t\tvalue: this.localVersion\r\n\t\t});\r\n\t}\r\n\treturn newSequence;\r\n};\r\n\r\nJSONPatchQueue.getPropertyByJsonPointer = function(obj, pointer) {\r\n\tvar parts = pointer.split('/');\r\n\tif(parts[0] === \"\") {\r\n\t\tparts.shift();\r\n\t}\r\n\tvar target = obj;\r\n\twhile(parts.length) {\r\n\t\tvar path = parts.shift().replace('~1', '/').replace('~0', '~');\r\n\t\tif(parts.length) {\r\n\t\t\ttarget = target[path];\r\n\t\t}\r\n\t}\r\n\treturn target[path];\r\n};\r\n\r\n/**\r\n * Reset queue internals and object to new, given state\r\n * @param obj object to apply new state to\r\n * @param newState versioned object representing desired state along with versions\r\n */\r\nJSONPatchQueue.prototype.reset = function(obj, newState){\r\n\tthis.remoteVersion = JSONPatchQueue.getPropertyByJsonPointer(newState, this.remotePath);\r\n\tthis.waiting = [];\r\n\tvar patch = [{ op: \"replace\", path: \"\", value: newState }];\r\n\tthis.apply(obj, patch);\r\n};\r\n\r\nif(typeof module !== undefined) {\r\n\tmodule.exports = JSONPatchQueue;\r\n\tmodule.exports.default = JSONPatchQueue;\r\n\t/* Babel demands this */\r\n\tmodule.exports.__esModule = true;\r\n}"]}